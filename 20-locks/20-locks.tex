\input{../preamble.tex}

\lecturenumber{20}
\title{Locks}
\version{2.0.0}

\begin{document}
  \begin{frame}[plain, noframenumbering]
    \titlepage
  \end{frame}

  \begin{slide}

    \slidetitle{Data Races Can Occur When Sharing Data}

    A data race is when two concurrent actions access the same variable

    and at least one of them is a write operation

  \end{slide}

  \begin{slide}

    \slidetitle{Atomic Operations are Indivisible}

    Any atomic instruction you may assume happens all at once
    \medskip

    This means you can not preempt it
    \medskip

    However, between two atomic instructions, you may be preempted

  \end{slide}

  \begin{slide}

    \slidetitle{Three Address Code (TAC) is Intermediate Code Used by Compilers}

    TAC is mostly used for analysis and optimization by compilers
    \medskip

    Statements represent one fundamental operation (assume each is atomic)

    \leftspace{}Useful to reason about data races and easier to read than assembly
    \medskip

    Statements have the form: $result := operand_1\:operator\:operand_2$

  \end{slide}

  \begin{slide}

    \slidetitle{GIMPLE is the TAC used by \texttt{gcc}}

    To see the GIMPLE representation of your compilation use:

    \leftspace{}{\tt -fdump-tree-gimple} flag
    \medskip

    To see all the three address code generated by the compiler (gcc) use:

    \leftspace{}{\tt -fdump-tree-all} flag
    \medskip

    GIMPLE is easier to reason about your code at a low-level without assembly

  \end{slide}

  \begin{slide}

    \slidetitle{\texttt{17-threads-implementation/pthread-datarace.c} Data Race}

    Instead of \texttt{count}, we'll look at \texttt{pcount} (the pointer to
    count, which is a global)
    \medskip

    The GIMPLE is the following:
    \begin{minted}{c}
D.1 = *pcount;
D.2 = D.1 + 1;
*pcount = D.2;
    \end{minted}
    \medskip
    
    Assuming that two threads execute this once each
    and initially \texttt{*pcount = 0}

    \leftspace{}What are the possible values of \texttt{*pcount}?

  \end{slide}

  \begin{slide}

    \slidetitle{
      To Analyze Data Races, You Have to Assume All Preemption Possibilities
    }

    Let's call the read and write from thread 1 R1 and W1 (R2 and W2 from thread 2)
    \medskip

    We'll assume no re-ordering of instructions: always read then write in
    a thread
    \medskip

    All possible orderings:

    \begin{center}
      \begin{tabular}{llll|r}
        \multicolumn{4}{c|}{Order} & {\tt *pcount}\\
        \hline
        R1 & W1 & R2 & W2 & 2 \\
        R1 & R2 & W1 & W2 & 1 \\
        R1 & R2 & W2 & W1 & 1 \\
        R2 & W2 & R1 & W1 & 2 \\
        R2 & R1 & W2 & W1 & 1 \\
        R2 & R1 & W1 & W2 & 1 \\
      \end{tabular}
    \end{center}

  \end{slide}

  \begin{slide}

    \slidetitle{You Can Create Mutexes Statically or Dynamically}

    \begin{minted}{c}
pthread_mutex_t m1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t m2;

pthread_mutex_init(&m2, NULL);
...
pthread_mutex_destroy(&m1);
pthread_mutex_destroy(&m2);
    \end{minted}
    \medskip

    If you want to include attributes, you need to use the dynamic version

  \end{slide}

  \begin{slide}

    \slidetitle{Everything Within the Lock and Unlock is a Critical Section}

    \begin{minted}{c}
// code
pthread_mutex_lock(&m1);
// protected code
pthread_mutex_unlock(&m1);
// more code
    \end{minted}
    \medskip

    Everything within the {\tt lock} and {\tt unlock} is protected
    \medskip

    Be careful to avoid deadlocks if you are using multiple mutexes
    \medskip

    There's also a {\tt pthread\_mutex\_trylock} if needed

  \end{slide}

  \begin{slide}

    \slidetitle{Adding a Lock to Prevent the Data Race}

    \begin{minted}{c}
static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; /* New */
static int counter = 0;

void* run(void* arg) {
    for (int i = 0; i < 100; ++i) {
        pthread_mutex_lock(&mutex); /* New */
        ++counter;
        pthread_mutex_unlock(&mutex); /* New */
    }
}

int main(int argc, char *argv[])
{
    // Create 8 threads
    // Join 8 threads
    pthread_mutex_destroy(&mutex); /* New */
    printf("counter = %i\n", counter);
}
    \end{minted}

  \end{slide}

  \begin{slide}

    \slidetitle{A Critical Section Means Only One Thread Executes Instructions}

    Safety (aka mutual exclusion)

    \leftspace{}There should only be a single thread in a critical section at
    once
    \medskip

    Liveness (aka progress)

    \leftspace{}If multiple threads reach a critical section, one must proceed

    \leftspace{}The critical section can't depend on outside threads

    \leftspace{}\leftspace{}You can mess up and deadlock (threads don't make progress)
    \medskip

    Bounded waiting (aka starvation-free)

    \leftspace{}A waiting thread must eventually proceed

  \end{slide}

  \begin{slide}

    \slidetitle{Critical Sections Should Also Have Minimal Overhead}

    Efficient

    \leftspace{}You don't want to consume resources while waiting
    \medskip

    Fair

    \leftspace{}You want each thread to wait approximately the same time
    \medskip

    Simple

    \leftspace{}It should be easy to use, and hard to misuse

  \end{slide}

  \begin{slide}

    \slidetitle{Similar to Libraries, You Want Layers of Synchronization}

    \centering
    \begin{tikzpicture}[every node/.style={draw, minimum width=8cm, inner sep=0.5em}]
      \node (app) {Properly synchronized application};
      \node [below=of app] (hl) {High-level synchronization primitives};
      \node [below=of hl] (hw) {Hardware-provided low-level atomic operations};
      \draw [->] (app) -- (hl);
      \draw [->] (hl) -- (hw);
    \end{tikzpicture}

  \end{slide}

  \begin{slide}

    \slidetitle{You Could Use a Lock to Implement Critical Sections}

    Assuming a uniprocessor operating system, your implementation could be:
    \medskip

    \begin{minted}{c}
void lock() {
  disable_interrupts();
}
void unlock() {
  enable_interrupts();
}   
    \end{minted}
    \medskip

    This would disable concurrency (assuming it ignores signals and interrupts)

    \leftspace{}This does not work on multiprocessors

  \end{slide}

  \begin{slide}

    \slidetitle{Let's Try to Implement a Lock in Software}

    \begin{minted}{c}
void init(int *l) {
  *l = 0;
}
void lock(int *l) {
  while (*l == 1);
  *l = 1;
}
void unlock(int *l) {
  *l = 0;
}   
    \end{minted}
    \medskip

    What's the issue with this implementation?

    \onslide<2->{\leftspace{}It's not safe (both threads can be in the critical section)}

    \onslide<2->{\leftspace{}It's not efficient, it wastes CPU cycles (busy wait)}

  \end{slide}

\end{document}
